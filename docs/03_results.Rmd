---
title: "Results"
output:
  md_document:
    variant: markdown_github
  html_document:
    df_print: paged
    toc: true
    toc_depth: 4
    toc_float: true
bibliography: "references.bib"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = TRUE,
  warning = TRUE, 
  cache.extra = knitr::rand_seed,
  out.width = "80%",
  results = "asis",
  dpi = 300,
  dev.args = list(png = list(type = "cairo"))
)

options(
  knitr.kable.NA = '-',
  knitr.duplicate.label = "allow",
  ggplot2.discrete.fill = c("#1A85FF", "#ff2976", "#FFC20A"),
  ggplot2.discrete.colour = c("#1A85FF", "#ff2976", "#FFC20A"),
  ggplot2.continuous.fill = scale_fill_gradient2(
    low = "#04bf78", mid = "white", high = "#FFC20A", 
    na.value = "white", limits = c(-0.4, 0.4)
  ),
  ggplot2.continuous.colour = scale_fill_gradient2(
    low = "#04bf78", mid = "white", high = "#FFC20A", 
    na.value = "white", limits = c(-0.4, 0.4)
  )
)
```

```{r prepare}
# import data
tar_load_globals()
tar_load_all()

theme_set(
  theme(
    title = element_text(size = 8, face = "bold"),
    
    legend.background = element_rect(fill = NA, colour = NA),
    legend.key = element_rect(fill = "white", colour = NA),
    legend.justification = "right",
    legend.direction = "horizontal",
    
    axis.line = element_line(colour = "black", size = 0.5),
    axis.ticks = element_line(colour = "black", size = 0.5),
    axis.text.x = element_text(colour = "black"),
    axis.text.y = element_text(colour = "black"),
    
    plot.caption.position = "plot",
    plot.title = element_text(hjust = 0.5),
    
    
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "white", colour = NA)
  )
)
```


# Model comparison


```{r comparison, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

tab_loos <- model_loos %>% 
  as.data.frame() %>% 
  rownames_to_column("model") %>% 
  arrange(desc(elpd_loo)) %>% 
  select(model, matches("elpd_loo"), matches("looic"), matches("diff")) %>%
  mutate(model = str_replace(model, "fit_", "Model ")) %>% 
  mutate_all(~ifelse(. == 0, NA, .)) %>% 
  gt(rowname_col = "model") %>% 
  tab_header(
    title = md("Table 2"),
    subtitle = md("Model performance and comparison using leave-one-out cross-validation")
  ) %>% 
  tab_source_note(
    md("*Note*. Outcomes of the leave-one-out cross-validation procedure. Each row indicates the values of the expected log-predicted density (*ELPD*), leave-one-out information creterion (*LOO-IC*), and the difference in *ELPD* (*LOO-diff*) between each model and the inmediately simpler model. Each value is accompanied by a standard error (*SE*) indicating the uncertainty of its estimate.")
  ) %>% 
  fmt_missing(everything(), missing_text = "-") %>% 
  fmt_number(2:7) %>% 
  cols_label(
    model = md("**Model**"),
    looic = md("***LOO<sub>IC</sub>***"),
    se_looic = md("***SE*<sub>IC</sub>**"),
    elpd_loo = md("***LOO<sub>ELPD</sub>***"),
    se_elpd_loo = md("***SE***"),
    elpd_diff = md("***LOO<sub>diff</sub>***"),
    se_diff = md("***SE<sub>diff</sub>***")
  ) %>% 
  tab_style(
    style = cell_text(align = "left", weight = "bold", size = "medium"),
    locations = cells_title(groups = "title")
  ) %>% 
  tab_style(
    style = cell_text(align = "left", size = "medium", style = "italic"),
    locations = cells_title(groups = "subtitle")
  ) %>% 
  tab_style(
    style = cell_text(align = "left", size = "medium"),
    locations = cells_source_notes()
  ) %>% 
  tab_style(
    style = list(cell_borders(sides = c("left", "right"), color = "white"),
                 cell_text(align = "center")),
    locations = list(
      cells_body(), cells_row_groups(), cells_column_spanners(), 
      cells_stub(), cells_source_notes(),
      cells_column_labels(), cells_stubhead()
    )
  ) %>% 
  tab_style(
    style = list(cell_text(align = "left", size = "medium"), 
                 cell_borders(sides = "all", color = "white")),
    locations = list(cells_stub(), cells_source_notes())
  ) %>% 
  tab_style(
    style = cell_text(align = "center", size = "medium", weight = "normal", style = "normal"),
    locations = list(cells_column_spanners(), cells_column_labels())
  ) %>% 
  tab_style(
    style = cell_borders(sides = "all", color = "white"),
    locations = cells_body(columns = 1:7)
  ) %>% 
  tab_style(
    style = cell_borders(sides = "top", color = "white"),
    locations = cells_body(columns = 1:7)
  ) %>% 
  gtsave(here("img", "loos.png"))

include_graphics(here("img", "loos.png"))


```


# Model outputs {.tabset .tab-pill}

```{r responses_coded, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
responses_coded <- responses %>% 
  # typos are considered correct responses
  mutate_at(vars(group), as.factor) %>% 
  # center predictors
  mutate_at(
    vars(lv_std, pthn_std, frequency_zipf_std),
    function(x) scale(x, center = TRUE, scale = TRUE)[,1]) %>% 
  # impute missing data
  mice(m = 5, print = FALSE, method = "pmm") %>% 
  complete() %>% 
  as_tibble() %>% 
  arrange(group, word)
```


## Fixed coefficients

```{r coefs_fixed_table, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

coefs <- fixef(fit_6) %>% 
  as.data.frame() %>% 
  rownames_to_column("variable") %>% 
  clean_names() %>% 
  mutate_at(vars(estimate:q97_5), ~ifelse(variable=="Intercept", inv_logit_scaled(.), ./4)) 

str_repl <- c(
  "Intercept" = "Intercept",
  "frequency_zipf_std" = "Frequency\n[+1 SD]",
  "pthn_std:lv_std" = "PTHN \u00d7 Levenshtein", 
  "lv_std:groupENGvs.SPA" = "Levenshtein \u00d7 Group 1",
  "lv_std:groupENGMCATvs.ENGMSPA" = "Levenshtein \u00d7 Group 2",
  "lv_std" = "Levenshtein\n[+1 SD]",
  "pthn_std" = "PTHN\n[+1 SD]",
  "groupENGvs.SPA" =  "Group 1\n[ENG-* vs. SPA-CAT]",
  "groupENGMCATvs.ENGMSPA" = "Group 2\n[ENG-CAT vs. ENG-SPA]"
)

coefs %>% 
  mutate(
    variable = str_remove(variable, "b_") %>% 
      str_replace_all(str_repl) %>%  
      factor(
        levels = c(
          "Intercept", "Frequency\n[+1 SD]", "PTHN\n[+1 SD]", 
          "Levenshtein\n[+1 SD]", "PTHN \u00d7 Levenshtein",
          "Group 1\n[ENG-* vs. SPA-CAT]",
          "Group 2\n[ENG-CAT vs. ENG-SPA]",
          "Levenshtein \u00d7 Group 1", "Levenshtein \u00d7 Group 2"
        )
      )
  ) %>% 
  select(-est_error) %>% 
  gt() %>% 
  fmt_percent(2:4) %>% 
  cols_merge(c("q2_5", "q97_5"), pattern = "[{1}, {2}]") %>% 
  cols_label(
    variable = md("**Predictor**"),
    estimate = md("**Mean**"),
    q2_5 = md("**95\\% CrI**"),
  ) %>% 
  tab_source_note("Estimated posterior distributions of coefficients in Model 6. A\\) Population-level effects. Distributions indicate the estimated posterior likelihood density of regression coefficients of fixed effects. Credible intervals (*CrI*), represented with increasingly lighter segmentents in the distribution indicate the range of values that contain the true value with 95\\%, 80\\%, and 50\\% probability. Black dots represent the mean of each distribution.") %>% 
  cols_align(align = "left") %>% 
  as_raw_html()
```


```{r posteriorfix, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, fig.cap="Estimated posterior distributions of coefficients in Model 4. A\\) Population-level effects. Distributions indicate the estimated posterior likelihood density of regression coefficients of fixed effects. Credible intervals (*CrI*), represented with increasingly lighter segmentents in the distribution indicate the range of values that contain the true value with 95\\%, 80\\%, and 50\\% probability. Black dots represent the mean of each distribution. B\\) Participant\\-level coefficient variability. The model estimated participant\\-level coefficients to account for the dependency between responses from the same participant. Distributions in this panel indicate the estimated variability across coefficients from different participants, expressed as standard deviations (*SD*). C\\) Correlation between participant\\-level effects. The model allowed participant-level coefficients to co\\-vary. This panel represents the Pearson correlations between each pair of coefficients, expressed as the mean of the posterior distribution of each  estimated correlation.", fig.height=7, fig.width=6.5}



coefs <- fixef(fit_6) %>% 
  as.data.frame() %>% 
  rownames_to_column("variable") %>% 
  clean_names() %>% 
  mutate_at(vars(estimate:q97_5), ~ifelse(variable=="Intercept", inv_logit_scaled(.), ./4)) %>% 
  group_split(variable) %>% 
  set_names(make_clean_names(map(., "variable"))) %>% 
  map(select, -variable) %>% 
  map(unlist)

str_repl <- c(
  "Intercept" = "Intercept",
  "frequency_zipf_std" = "Frequency\n[+1 SD]",
  "pthn_std:lv_std" = "PTHN \u00d7 Levenshtein", 
  "lv_std:group1" = "Levenshtein \u00d7 Group 1",
  "lv_std:group2" = "Levenshtein \u00d7 Group 2",
  "lv_std" = "Levenshtein\n[+1 SD]",
  "pthn_std" = "PTHN\n[+1 SD]",
  "group1" =  "Group 1\n[ENG-* vs. SPA-CAT]",
  "group2" = "Group 2\n[ENG-CAT vs. ENG-SPA]"
)


# fixed effects
post_fix <- posterior_draws_fixed %>% 
  filter(str_detect(.variable, "b_")) %>% 
  mutate(
    .variable_name = str_remove(.variable, "b_") %>% 
      str_replace_all(str_repl) %>%  
      factor(
        levels = c(
          "Intercept", "Frequency\n[+1 SD]", "PTHN\n[+1 SD]", 
          "Levenshtein\n[+1 SD]", "PTHN \u00d7 Levenshtein",
          "Group 1\n[ENG-* vs. SPA-CAT]",
          "Group 2\n[ENG-CAT vs. ENG-SPA]",
          "Levenshtein \u00d7 Group 1", "Levenshtein \u00d7 Group 2"
        )
      ),
    .value = ifelse(str_detect(.variable, "Intercept"), inv_logit_scaled(.value), .value/4)
  ) %>% 
  arrange(.variable) %>% 
  ggplot(aes(.value, fct_rev(.variable_name))) +
  geom_vline(xintercept = 0) +
  stat_slab(aes(fill = stat(cut_cdf_qi(cdf, .width = c(.5, .8, .95), labels = percent_format())))) +
  stat_pointinterval(.width = 0, point_size = 1) +
  scale_fill_manual(values = c("#1A85FF", "#9ccaff", "#d2e5fc"), na.translate = FALSE) +
  scale_x_continuous(labels = function(x) percent(round(x, 1))) +
  labs(x = "P(Correct)", y = "Posterior probability density", fill = "CrI") +
  theme(
    legend.position = c(1, 0.25),
    legend.direction = "vertical",
    legend.background = element_rect(fill = "grey95"),
    legend.key = element_rect(fill = "grey95", colour = "grey95"), 
    legend.key.height = unit(0.1, "cm"),
    axis.title.y = element_blank(),
    legend.text = element_text(size = 7),
    axis.text.x = element_text(colour = "black"),
    axis.text.y = element_text(colour = "black", hjust = 1),
    axis.ticks.y = element_blank(),
    panel.grid.major.y = element_line(colour = "grey", size = 0.5)
  ) 



# SD of random effects
post_sd_data <- posterior_draws_fixed %>% 
  filter(str_detect(.variable, "sd_")) %>% 
  mutate(
    .variable_name = str_remove(.variable, "sd_participant__|sd_word__") %>% 
      str_replace_all(str_repl) %>% 
      factor(
        levels = c(
          "Intercept", "Frequency\n[+1 SD]", "PTHN\n[+1 SD]", 
          "Levenshtein\n[+1 SD]", "PTHN \u00d7 Levenshtein",
          "Group 1\n[ENG-* vs. SPA-CAT]",
          "Group 2\n[ENG-CAT vs. ENG-SPA]",
          "Levenshtein \u00d7 Group 1", "Levenshtein \u00d7 Group 2"
        )
      ),
    group = case_when(
      str_detect(.variable, "participant") ~ "Participants",
      str_detect(.variable, "word") ~ "Words"
    ),
    .value = ifelse(str_detect(.variable, "Intercept"), inv_logit_scaled(.value), .value/4)
  ) 

post_sd <- ggplot(filter(post_sd_data, group=="Participants"), aes(.value, fct_rev(.variable_name))) +
  stat_slab(aes(fill = stat(cut_cdf_qi(cdf, .width = c(.5, .8, .95), labels = percent_format())))) +
  stat_pointinterval(.width = 0, point_size = 1) +
  scale_fill_manual(values = c("#ff2976", "#f2a7c2", "#fcd9e6"), na.translate = FALSE) +
  scale_x_continuous(labels = percent, limits = c(0, 1)) +
  labs(x = "SDs in P(Correct)", title = "By participant", fill = "CrI") +
  theme(axis.text.x = element_blank()) +
  
  ggplot(filter(post_sd_data, group=="Words"), aes(.value, fct_rev(.variable_name))) +
  stat_slab(aes(fill = stat(cut_cdf_qi(cdf, .width = c(.5, .8, .95), labels = percent_format())))) +
  stat_pointinterval(.width = 0, point_size = 1) +
  scale_x_continuous(labels = percent, limits = c(0, 1)) +
  labs(x = "SDs in P(Correct)", title = "By item", fill = "CrI") +
  
  plot_layout(ncol = 1, heights = c(0.85, 0.15), guides = "collect") &
  theme(
    legend.position = "none",
    axis.text.y = element_text(hjust = 1),
    axis.title.x = element_blank(),
    legend.direction = "vertical",
    axis.title.y = element_blank(),
    legend.background = element_rect(fill = "grey95"),
    legend.key.height = unit(0.1, "cm"),
    legend.key = element_rect(fill = "grey95", colour = "grey95"),
    legend.text = element_text(size = 7),
    axis.ticks.y = element_blank(),
    panel.grid.major.y = element_line(colour = "grey", size = 0.5)
  ) 


# Pearson correlations between random effects
corr_mat <- VarCorr(fit_6, summary = TRUE)$participant$cor 
corr_names <- rownames(VarCorr(fit_6, summary = TRUE)$participant$cor)

corr_mat <- corr_mat %>% 
  as_tibble() %>% 
  select(matches("Estimate")) %>% 
  rename_all(str_remove, "Estimate.") %>% 
  mutate(term1 = corr_names)

corr_mat[lower.tri(corr_mat)] <- NA

corr_data <- corr_mat %>% 
  as.data.frame() %>% 
  pivot_longer(-term1, names_to = "term2", values_to = ".value") %>% 
  drop_na(.value)

post_cors <- corr_data %>% 
  mutate(term1 = factor(term1, levels = names(str_repl), ordered = TRUE),
         term2 = factor(term2, levels = names(str_repl), ordered = TRUE)) %>% 
  mutate_at(vars(term1, term2), str_replace_all, str_repl) %>% 
  mutate(
    .value_label = case_when(term1==term2 ~ NA_character_, TRUE ~ printnum(.value, gt1 = FALSE)),
    .value = case_when(term1==term2 ~ NA_real_, TRUE ~ .value)
  ) %>% 
  filter(term1 != "PTHN × Levenshtein", term2 != "Intercept") %>% 
  ggplot(aes(fct_inorder(term1), fct_rev(fct_inorder(term2)), fill = .value)) +
  geom_tile(na.rm = TRUE) +
  geom_text(aes(label = .value_label), size = 3, na.rm = TRUE) +
  labs(x = "Term 1", y = "Term 2", fill = "Posterior\ncorrelation") +
  scale_fill_gradient2(
    low = "#04bf78", mid = "white", high = "#FFC20A", 
    na.value = "white", limits = c(-0.4, 0.4)
  ) +
  scale_x_discrete(position = "top") +
  coord_equal() +
  theme(
    legend.position = c(1, 1),
    legend.direction = "horizontal",
    legend.key.height = unit(0.1, "cm"),
    legend.key.width = unit(0.3, "cm"),
    legend.justification = c(1, 1),
    legend.title = element_blank(),
    legend.text = element_text(size = 5),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks = element_blank(),
    axis.text.x = element_text(size = 6, angle = 90, hjust = 0, vjust = 1),
    axis.text.y = element_text(size = 6, vjust = 1, hjust = 1)
  )

post_fix / ((post_sd | post_cors) + plot_layout(widths = c(0.6, 0.4))) +
  plot_layout() +
  plot_annotation(tag_levels = "A")



```


## Model comparison

Leave-one-out cross-validation. The more negative is `elpd_diff` (and the larger its magnitude compared to its corresponding standard error), the better it first the data compared to the null model (`~ 1 + (1 | participant)`). The model that fits the data the best is the extended model.

```{r model_comparison, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
tab_loos <- model_loos %>% 
  as.data.frame() %>% 
  rownames_to_column("model") %>% 
  arrange(desc(elpd_loo)) %>% 
  select(model, matches("elpd_loo"), matches("looic"), matches("diff")) %>%
  mutate(model = str_replace(model, "fit_", "Model ")) %>% 
  mutate_all(~ifelse(. == 0, NA, .)) %>% 
  gt(rowname_col = "model") %>% 
  tab_header(
    title = md("Table 2"),
    subtitle = md("Model performance and comparison using leave-one-out cross-validation")
  ) %>% 
  tab_source_note(
    md("*Note*. Outcomes of the leave-one-out cross-validation procedure. Each row indicates the values of the expected log-predicted density (*ELPD*), leave-one-out information creterion (*LOO-IC*), and the difference in *ELPD* (*LOO-diff*) between each model and the inmediately simpler model. Each value is accompanied by a standard error (*SE*) indicating the uncertainty of its estimate.")
  ) %>% 
  fmt_missing(everything(), missing_text = "-") %>% 
  fmt_number(2:7) %>% 
  cols_label(
    model = md("**Model**"),
    looic = md("***LOO<sub>IC</sub>***"),
    se_looic = md("***SE*<sub>IC</sub>**"),
    elpd_loo = md("***LOO<sub>ELPD</sub>***"),
    se_elpd_loo = md("***SE***"),
    elpd_diff = md("***LOO<sub>diff</sub>***"),
    se_diff = md("***SE<sub>diff</sub>***")
  ) %>% 
  tab_style(
    style = cell_text(align = "left", weight = "bold", size = "medium"),
    locations = cells_title(groups = "title")
  ) %>% 
  tab_style(
    style = cell_text(align = "left", size = "medium", style = "italic"),
    locations = cells_title(groups = "subtitle")
  ) %>% 
  tab_style(
    style = cell_text(align = "left", size = "medium"),
    locations = cells_source_notes()
  ) %>% 
  tab_style(
    style = list(cell_borders(sides = c("left", "right"), color = "white"),
                 cell_text(align = "center")),
    locations = list(
      cells_body(), cells_row_groups(), cells_column_spanners(), 
      cells_stub(), cells_source_notes(),
      cells_column_labels(), cells_stubhead()
    )
  ) %>% 
  tab_style(
    style = list(cell_text(align = "left", size = "medium"), 
                 cell_borders(sides = "all", color = "white")),
    locations = list(cells_stub(), cells_source_notes())
  ) %>% 
  tab_style(
    style = cell_text(align = "center", size = "medium", weight = "normal", style = "normal"),
    locations = list(cells_column_spanners(), cells_column_labels())
  ) %>% 
  tab_style(
    style = cell_borders(sides = "all", color = "white"),
    locations = cells_body(columns = 1:7)
  ) %>% 
  tab_style(
    style = cell_borders(sides = "top", color = "white"),
    locations = cells_body(columns = 1:7)
  ) %>% 
  as_raw_html()

```


## Random effects

```{r post_re_participant, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
post_re <- posterior_draws_random$participants %>% 
  mean_qi() %>% 
  ungroup() %>% 
  left_join(select(participants, participant, group)) %>% 
  arrange(group, participant, .param) %>% 
  mutate(.param_name = str_replace_all(.param, str_repl) %>%  
           factor(
             levels = c(
               "Intercept", "Frequency\n[+1 SD]", "PTHN\n[+1 SD]", 
               "Levenshtein\n[+1 SD]", "PTHN \u00d7 Levenshtein",
               "Group 1\n[ENG-* vs. SPA-CAT]",
               "Group 2\n[ENG-CAT vs. ENG-SPA]",
               "Levenshtein \u00d7 Group 1", "Levenshtein \u00d7 Group 2"
             )
           ))

ggplot(post_re, 
       aes(.value, sort(as.factor(participant)), 
           xmin = .lower, xmax = .upper, colour = group)) +
  facet_grid(group~.param_name, scales = "free") +
  geom_errorbarh(height = 0, alpha = 0.75) +
  geom_point(size = 0.1, shape = 4) +
  geom_vline(xintercept = 0) +
  labs(x = "Participant-level adjustment", y = "Participant", colour = "Group",
       title = "By participant") +
  scale_color_manual(values = c("#1A85FF", "#ff2976", "#FFC20A"), na.translate = FALSE) &
  theme(
    legend.position = "none",
    legend.title = element_blank(),
    panel.grid.major.x = element_line(colour = "grey", linetype = "dotted"),
    axis.text.x = element_text(size = 9),
    axis.text.y = element_blank(),
    axis.ticks = element_blank()
  )
```


```{r post_re_word, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
fixed_intercept <- fixef(fit_6)[1,c(1, 3, 4)] %>% 
  inv_logit_scaled()

post_re <- posterior_draws_random$words   %>% 
  ungroup() %>% 
  arrange(word, .param) %>% 
  mutate(
    .param_name = str_replace_all(.param, str_repl) %>%  
      factor(
        levels = c(
          "Intercept", "Frequency\n[+1 SD]", "PTHN\n[+1 SD]", 
          "Levenshtein\n[+1 SD]", "PTHN \u00d7 Levenshtein",
          "Group 1\n[ENG-* vs. SPA-CAT]",
          "Group 2\n[ENG-CAT vs. ENG-SPA]",
          "Levenshtein \u00d7 Group 1", "Levenshtein \u00d7 Group 2"
        )
      ),
    .value = inv_logit_scaled(.value)
  )

ggplot(post_re, aes(.value, reorder(as.factor(word), .value))) +
  geom_vline(xintercept = fixed_intercept[1], colour = "grey", size = 1) +
  
  stat_interval(
    size = 1.5,
    .width = c(0.5, 0.67, 0.95)
  ) +
  annotate(
    geom = "text",
    x = 0.7,
    y = 100,
    size = 3,
    hjust = 0.5,
    label = "Item accuracy \n(95%, 67%, and 50% CrI \nof item-level intercepts)"
  ) +
  annotate(
    geom = "rect",
    alpha = 0.15,
    xmin = fixed_intercept[2],
    xmax = fixed_intercept[3],
    ymin = -Inf,
    ymax = Inf
  ) +
  annotate(
    x = 0.7,
    xend = 0.6,
    y = 108,
    yend = 130,
    geom = "curve",
    curvature = 0.25,
    arrow = arrow(length = unit(0.2, "cm"))
  ) +
  annotate(
    geom = "text",
    x = 0.8,
    y = 10,
    size = 3,
    hjust = 0.5,
    label = "Global posterior accuracy\n(Mean ± 95% CrI of the \npopulation-level intercept)"
  ) +
  annotate(
    x = 0.7,
    xend = fixed_intercept[1]+0.05,
    y = 17,
    yend = 30,
    geom = "curve",
    curvature = 0.2,
    arrow = arrow(length = unit(0.2, "cm"))
  ) +
  labs(
    x = "Posterior probability of correct response",
    y = "Item",
    colour = "Credible Interval (CrI)",
    caption = "Credible intervals cover the range of values of the sampling space that \ncontain the true value with a given certainty."
  ) +
  scale_color_manual(
    values = c("#d2e5fc", "#9ccaff", "#1A85FF"),
    na.translate = FALSE, 
    labels = paste0(c(95, 67, 50), "%")
  ) +
  scale_x_continuous(limits = c(0, 1), labels = percent) +
  theme(
    legend.position = c(0.1, 0.9),
    legend.direction = "vertical",
    legend.justification = "left",
    legend.key = element_rect(fill = NA, colour = NA),
    panel.grid.major.x = element_line(colour = "grey", linetype = "dotted"),
    axis.text.x = element_text(size = 9),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    axis.title = element_text(size = 10),
    plot.caption.position = "plot",
    plot.caption = element_text(size = 9, hjust = 0, face = "plain", margin = margin(t = unit(3, "cm")))
  )

ggsave(here("img", "accuracy.png"), height = 9, width = 5, dpi = 500)
```

## Marginal effects


```{r emmeans_pthn, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, fig.width=7, fig.height=6}

m <- posterior_epreds_fixed %>% 
  mutate_at(vars(pthn_std, frequency_zipf_std), function(x) paste0(x, " SD")) %>% 
  mutate(
    pthn_std = case_when(
      pthn_std=="-1 SD" ~ "Low PTHN",
      pthn_std=="0 SD" ~ "Mean PTHN",
      pthn_std=="1 SD" ~ "High PTHN"
    ),
    frequency_zipf_std = case_when(
      frequency_zipf_std=="-1 SD" ~ "Low frequency",
      frequency_zipf_std=="0 SD" ~ "Mean frequency",
      frequency_zipf_std=="1 SD" ~ "High frequency"
    )
  ) 


ggplot(m, aes(lv_std, .epred, colour = pthn_std, fill = pthn_std)) +
  facet_wrap(~group) +
  geom_hline(yintercept = 0.5, colour = "grey") +
  geom_line(aes(group = interaction(pthn_std, .draw)), alpha = 0.25, size = 0.5, show.legend = TRUE) +
  stat_summary(aes(linetype = pthn_std), fun = mean, geom = "line", 
               colour = "black", size = 0.75, show.legend = TRUE) +
  annotate("segment", x = -0.5, xend = -0.9, y = 0.85, yend = 0.85, 
           arrow = arrow(length = unit(0.1, "cm")), size = .5) +
  annotate("segment", x = 2.25, xend = 2.65, y = 0.85, yend = 0.85, 
           arrow = arrow(length = unit(0.1, "cm")), size = .5) +
  annotate("text", x = -0.5, y = 0.95, size = 2.75, label = "Less similar") +
  annotate("text", x = 2.15, y = 0.95, size = 2.75, label = "More similar") +
  labs(x = "Phonological similarity\n(Levenshtein, SD)", y = "P(Correct)", 
       colour = "PTHN", fill = "PTHN", linetype = "PTHN",
       title = "Population-level predictions") +
  scale_color_manual(values = c("#1E88E5", "#ff2976")) +
  scale_y_continuous(
    labels = function(x) percent(round(x, 2)),
    limits = c(0, 1),
    breaks = seq(0, 1, 0.1)
  ) +
  theme(
    legend.position = "top",
    plot.title = element_blank()
  )


```





# Accuracy

## Accuracy by item

```{r accuracy_item, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
responses_item <- responses %>%
  group_by(group, word) %>%
  summarise(
    correct_sum = sum(correct, na.rm = TRUE),
    correct_n = sum(!is.na(correct), na.rm = TRUE),
    .groups = "drop"
  ) %>% 
  mutate(
    correct_prop = prop_adj(correct_sum, correct_n),
    correct_se = prop_adj_se(correct_sum, correct_n),
    word_label = reorder_within(word, by = correct_prop, within = group)
  )

ggplot(responses_item, aes(reorder(word_label, correct_prop), correct_prop, ymin = correct_prop-correct_se, ymax = correct_prop+correct_se, colour = group)) +
  facet_wrap(~group, scales = "free_y") +
  geom_hline(yintercept = 0.5, colour = "black") +
  geom_errorbar() +
  geom_point(size = 0.5) +
  labs(y = "Correct responses", x = "Word", colour = "Group") +
  coord_flip() +
  scale_color_manual(values = c("#1A85FF", "#ff2976", "#FFC20A"), na.translate = FALSE) +
  scale_y_continuous(limits = c(0, 1), labels = percent) +
  theme(
    legend.position = "none",
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    axis.text.x = element_text(size = 9),
    panel.grid.major.x = element_line(colour = "grey", linetype = "dotted")
  )

```

## Accuracy by participant

```{r responses_participant, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
responses_participant <- responses %>%
  group_by(group, participant) %>%
  summarise(
    correct_sum = sum(correct, na.rm = TRUE),
    correct_n = sum(!is.na(correct), na.rm = TRUE),
    .groups = "drop"
  ) %>% 
  mutate(
    correct_prop = prop_adj(correct_sum, correct_n),
    correct_se = prop_adj_se(correct_sum, correct_n),
    participant_label = reorder_within(participant, by = correct_prop, within = group)
  )

ggplot(responses_participant, aes(reorder(participant_label, correct_prop), correct_prop, ymin = correct_prop-correct_se, ymax = correct_prop+correct_se, colour = group)) +
  facet_wrap(~group, scales = "free_y") +
  geom_hline(yintercept = 0.5) +
  geom_errorbar(width = 0.5) +
  geom_point(size = 1) +
  labs(y = "Correct responses", x = "Participant", colour = "Group") +
  coord_flip() +
  scale_color_manual(values = c("#1A85FF", "#ff2976", "#FFC20A"), na.translate = FALSE) +
  scale_y_continuous(limits = c(0, 1), labels = scales::percent) +
  theme(
    legend.position = "none",
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    axis.text.x = element_text(size = 9),
    panel.grid.major.x = element_line(colour = "grey", linetype = "dotted")
  )

```

# Model diagnostics

```{r traceplots, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

posterior_draws_fixed %>% 
  mutate(
    .chain = as.factor(.chain),
    .variable_name = str_replace_all(.variable, str_repl) %>% 
      str_remove("b_")
    ) %>% 
  ggplot(aes(.iteration, .value, colour = .chain)) +
  facet_wrap(~.variable_name, scales = "free_y") +
  geom_line() +
  labs(x = "Iteration", y = "Value", color = "Chain") +
  scale_colour_manual(values = c("#1A85FF", "#ff2976", "#FFC20A", "04bf78"), na.translate = FALSE) +
  theme(legend.position = "top")


```

